import streamlit as st

st.set_page_config(layout="centered")

import pandas as pd
import tempfile
import base64
from collections import Counter
from itertools import combinations
import random
import json
import io

st.markdown(
    """
    <style>
    /* OdsazenÃ­ celÃ©ho hlavnÃ­ho obsahu od hornÃ­ho okraje */
    main > div:has(.block-container) {
        padding-top: 60px;
    }
    .stApp {
        background-image: url('https://img41.rajce.idnes.cz/d4102/19/19642/19642596_185bd55429092dbd5dccd20ff2c485cb/images/card_back_texture.jpg?ver=0');
        background-repeat: repeat;
        background-size: 100px 100px;
        background-attachment: fixed;
        font-family: 'Segoe UI', sans-serif;
    }

    /* PozadÃ­ hlavnÃ­ho kontejneru â€“ textura papÃ­ru */
    .block-container {
        background-image: url('https://img41.rajce.idnes.cz/d4102/19/19642/19642596_185bd55429092dbd5dccd20ff2c485cb/images/paper.jpg?ver=0');
        background-repeat: repeat;
        background-size: 300px 300px;
        background-color: rgba(255, 255, 255, 0.75);
        border-radius: 16px;
        padding: 2rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    h1 {
        margin-top: 0px;
        text-align: left;
        color: #2c2c2c;
        text-shadow: 1px 1px 1px #fff9;
    }

    h2, h3 {
        color: #2c2c2c;
        text-shadow: 1px 1px 1px #fff9;
    }
        /* Obal vstupnÃ­ch polÃ­ â€“ zarovnÃ¡nÃ­ na stÅ™ed */
        .param-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        /* Å Ã­Å™ka vÅ¡ech vstupnÃ­ch polÃ­ */
        .param-container .stNumberInput, 
        .param-container div[data-baseweb="select"] {
            width: 300px !important;
        }


    .stTextInput, .stNumberInput, .stSelectbox {
        background-color: #ffffffcc;
        border-radius: 8px;
    }

    button[kind="primary"] {
        background-color: #8b5e3c;
        color: white;
        border-radius: 8px;
        border: none;
        padding: 0.5rem 1.5rem;
        font-weight: bold;
    }

    button[kind="primary"]:hover {
        background-color: #5c3a1e;
    }
    </style>
    """,
    unsafe_allow_html=True
)

# ===== FUNKCE PRO UKLÃDÃNÃ A NAÄŒÃTÃNÃ =====
def export_tournament_data():
    """Exportuje data turnaje pro staÅ¾enÃ­"""
    tournament_data = {
        'players': st.session_state.get('players'),
        'rounds': st.session_state.get('rounds'),
        'vklad': st.session_state.get('vklad'),
        'group_size': st.session_state.get('group_size'),
        'tournament_type': st.session_state.get('tournament_type'),
        'player_names': st.session_state.get('player_names', []),
        'rozlosovani': st.session_state.get('rozlosovani', []),
        'results': st.session_state.get('results', {}),
        'current_round': st.session_state.get('current_round', 1),
        'finished': st.session_state.get('finished', False),
        'player_scores': st.session_state.get('player_scores', {})
    }
    return json.dumps(tournament_data, ensure_ascii=False, indent=2)

def import_tournament_data(json_data):
    """Importuje data turnaje z JSON"""
    try:
        data = json.loads(json_data)
        
        # ObnovenÃ­ session state
        st.session_state.players = data.get('players')
        st.session_state.rounds = data.get('rounds')
        st.session_state.vklad = data.get('vklad')
        st.session_state.group_size = data.get('group_size')
        st.session_state.tournament_type = data.get('tournament_type')
        st.session_state.player_names = data.get('player_names', [])
        st.session_state.rozlosovani = data.get('rozlosovani', [])
        st.session_state.results = data.get('results', {})
        st.session_state.current_round = data.get('current_round', 1)
        st.session_state.finished = data.get('finished', False)
        st.session_state.player_scores = data.get('player_scores', {})
        st.session_state.confirmed = True
        
        # Pokud je turnaj dokonÄenÃ½, pÅ™eskoÄÃ­me na vÃ½sledky
        if st.session_state.finished:
            st.success("NaÄten dokonÄenÃ½ turnaj!")
        elif st.session_state.results:
            # Najdeme nejvyÅ¡Å¡Ã­ kolo s vÃ½sledky
            max_round_with_results = max(int(k) for k in st.session_state.results.keys())
            # NastavÃ­me current_round na dalÅ¡Ã­ kolo po poslednÃ­m s vÃ½sledky
            st.session_state.current_round = max_round_with_results + 1
            st.success(f"NaÄteno {len(st.session_state.results)} kol s vÃ½sledky. PokraÄujte v kole {st.session_state.current_round}")
        
        return True
    except Exception as e:
        st.error(f"Chyba pÅ™i importu dat: {e}")
        return False

col1, col2 = st.columns([0.7, 0.3])
with col1:
    st.header("RozlosovÃ¡nÃ­ a evidence mariÃ¡Å¡ovÃ©ho turnaje")
with col2:
    st.image("https://marias-turnaj.zya.me/marias.png")

# ===== TLAÄŒÃTKA PRO SPRÃVU TURNAJE =====
if st.session_state.get('confirmed'):
    st.sidebar.markdown("---")
    st.sidebar.subheader("SprÃ¡va turnaje")
    
    # Export turnaje
    tournament_json = export_tournament_data()
    st.sidebar.download_button(
        label="ğŸ’¾ UloÅ¾it turnaj",
        data=tournament_json,
        file_name=f"marias_turnaj_{pd.Timestamp.now().strftime('%Y%m%d_%H%M')}.json",
        mime="application/json"
    )
    
    # Import turnaje
    st.sidebar.markdown("---")
    st.sidebar.subheader("NaÄÃ­st turnaj")
    
    uploaded_file = st.sidebar.file_uploader("Vyberte soubor s turnajem", type=['json'])
    if uploaded_file is not None:
        try:
            json_data = uploaded_file.getvalue().decode('utf-8')
            if st.sidebar.button("ğŸ“¤ NaÄÃ­st turnaj ze souboru"):
                if import_tournament_data(json_data):
                    st.sidebar.success("Turnaj ÃºspÄ›Å¡nÄ› naÄten!")
                    st.rerun()
        except Exception as e:
            st.sidebar.error(f"Chyba pÅ™i naÄÃ­tÃ¡nÃ­ souboru: {e}")

# ===== SEATING DEFINITIONS (ZKRÃCENÃ‰) =====
SEATING_DEFINITIONS = {
    '9_3': {
        'group_size': 3,
        'description': "Kirkman Triple System (KTS(9))",
        'rounds': [
            [[1,2,3], [4,5,6], [7,8,9]],
            [[1,4,7], [2,5,8], [3,6,9]],
            [[1,5,9], [2,6,7], [3,4,8]],
            [[1,6,8], [2,4,9], [3,5,7]]
        ]
    },
    '12_3': {
        'group_size': 3,
        'description': "Kirkman Triple System (KTS(12))",
        'rounds': [
            [[1,2,3], [4,5,6], [7,8,9], [10,11,12]],
            [[1,4,10], [5,7,11], [2,6,8], [3,9,12]],
            [[1,5,9], [4,8,12], [2,7,10], [3,6,11]]
        ]
    },
    '15_3': {
        'group_size': 3,
        'description': "Kirkman Triple System (KTS(15))",
        'rounds': [
            [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]],
            [[1,4,7],[2,5,10],[3,6,13],[8,11,14],[9,12,15]],
            [[1,5,14],[2,4,15],[3,8,12],[6,9,11],[7,10,13]]
        ]
    },
    '18_3': {
        'group_size': 3,
        'description': "Kirkman Triple System (KTS(18))",
        'rounds': [
            [[1,2,3],[4,5,6],[7,8,9],[10,17,15],[13,11,18],[16,14,12]],
            [[1,11,12],[4,14,15],[7,17,18],[10,8,6],[13,2,9],[16,5,3]]
        ]
    },
    '16_4': {
        'group_size': 4,
        'description': "Å˜eÅ¡itelnÃ½ SteinerÅ¯v ÄtyÅ™nÃ¡sobnÃ½ systÃ©m (RSQS(16))",
        'rounds': [
            [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]],
            [[1,5,9,13], [2,6,10,14], [3,7,11,15], [4,8,12,16]],
            [[1,6,11,16], [2,5,12,15], [3,8,9,14], [4,7,10,13]]
        ]
    },
    '20_4': {
        'group_size': 4,
        'description': "Å˜eÅ¡itelnÃ½ SteinerÅ¯v ÄtyÅ™nÃ¡sobnÃ½ systÃ©m (RSQS(20))",
        'rounds': [
            [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16], [17,18,19,20]],
            [[1,5,9,13], [2,6,10,17], [3,7,14,18], [4,11,15,19], [8,12,16,20]]
        ]
    },
    '24_4': {
        'group_size': 4,
        'description': "Å˜eÅ¡itelnÃ½ SteinerÅ¯v ÄtyÅ™nÃ¡sobnÃ½ systÃ©m (RSQS(24))",
        'rounds': [
            [[1,2,11,21],[9,10,19,5],[17,18,3,13],[4,7,6,24],[8,12,14,15],[16,20,22,23]],
            [[1,3,12,22],[9,11,20,6],[17,19,4,14],[5,8,7,18],[2,13,15,16],[10,21,23,24]]
        ]
    }
}

# ===== PÅ˜ÃPRAVA MOÅ½NOSTÃ Z SEATING_DEFINITIONS =====
available_keys = list(SEATING_DEFINITIONS.keys())
available_options = sorted(set((int(k.split('_')[0]), int(k.split('_')[1])) for k in available_keys))
grouped_by_group_size = {}
for p, g in available_options:
    grouped_by_group_size.setdefault(g, []).append(p)

# ===== Krok 1: Volba poÄtu hrÃ¡ÄÅ¯ a hry =====
if 'confirmed' not in st.session_state:
    st.session_state.confirmed = False

if not st.session_state.confirmed:
    col1, col2 = st.columns(2)
    with col1:
        group_size = st.radio("PoÄet hrÃ¡ÄÅ¯ u stolu", sorted(grouped_by_group_size.keys()), index=0, horizontal=True)
    with col2:
        tournament_type = st.radio("Typ turnaje", ["UNIKÃTNÃ", "Å VÃCARSKÃ SYSTÃ‰M"], horizontal=True)
    col1, col2 = st.columns(2)
    with col1:
        if tournament_type == "UNIKÃTNÃ":
            player_options = grouped_by_group_size[group_size]
            players = st.selectbox("PoÄet hrÃ¡ÄÅ¯", sorted(player_options))
        else:
            if group_size == 3:
                min_players = 9
            else:
                min_players = 16
            player_options = list(range(min_players, 201, group_size))
            players = st.selectbox("PoÄet hrÃ¡ÄÅ¯", player_options)
        
    with col2:
        if tournament_type == "UNIKÃTNÃ":
            key = f"{players}_{group_size}"
            max_rounds = len(SEATING_DEFINITIONS[key]["rounds"])
            rounds = st.selectbox("PoÄet kol", list(range(1, max_rounds + 1)))
        else:
            rounds = st.selectbox("PoÄet kol", list(range(1, 16)))
    
        vklad = st.number_input("StartovnÃ­ vklad na hrÃ¡Äe (KÄ)", min_value=0, step=10)

    if st.button("Potvrdit Ãºdaje"):
        st.session_state.players = players
        st.session_state.rounds = rounds
        st.session_state.vklad = vklad
        st.session_state.group_size = group_size
        st.session_state.tournament_type = tournament_type
        st.session_state.confirmed = True
        st.rerun()
else:
    st.info(f"{st.session_state.players} hrÃ¡ÄÅ¯, {st.session_state.rounds} kol, {st.session_state.group_size} u stolu, vklad {st.session_state.vklad} KÄ, {st.session_state.tournament_type}")
    if st.button("ğŸ” ZmÄ›nit Ãºdaje"):
        for k in ["confirmed", "players", "rounds", "vklad", "group_size", "player_names", "rozlosovani", "results", "finished", "current_round", "tournament_type", "player_scores"]:
            st.session_state.pop(k, None)
        st.rerun()

# ===== Krok 2: ZadÃ¡nÃ­ jmen hrÃ¡ÄÅ¯ =====
if st.session_state.confirmed and 'player_names' not in st.session_state:
    st.subheader("Zadejte jmÃ©na hrÃ¡ÄÅ¯")
    name_inputs = []
    col1, col2 = st.columns(2)
    for i in range(1, st.session_state.players + 1):
        with (col1 if i <= st.session_state.players / 2 else col2):
            name = st.text_input(f"HrÃ¡Ä {i}", value=f"HrÃ¡Ä {i}", key=f"name_{i}")
            name_inputs.append(name.strip())

    duplicates = {name for name, count in Counter(name_inputs).items() if count > 1}
    for name in duplicates:
        st.markdown(f"<span style='color:red;'>âš ï¸ DuplicitnÃ­ jmÃ©no: {name}</span>", unsafe_allow_html=True)

    if not duplicates and st.button("PokraÄovat"):
        st.session_state.player_names = name_inputs
        if st.session_state.tournament_type == "Å VÃCARSKÃ SYSTÃ‰M":
            st.session_state.player_scores = {name: 0 for name in name_inputs}
        st.rerun()

# ===== Krok 3: RozlosovÃ¡nÃ­ =====
def generate_swiss_round(players, group_size, current_round):
    """Generate pairings for a Swiss system round"""
    if current_round == 1:
        random.shuffle(players)
    else:
        sorted_players = sorted(players, key=lambda x: st.session_state.player_scores[x], reverse=True)
        players = sorted_players
    
    groups = []
    for i in range(0, len(players), group_size):
        group = players[i:i+group_size]
        if len(group) == group_size:
            groups.append(group)
    
    if len(players) % group_size != 0:
        leftovers = len(players) % group_size
        for i in range(leftovers):
            groups[i].append(players[-(i+1)])
    
    return groups

if 'player_names' in st.session_state and 'rozlosovani' not in st.session_state:
    if st.session_state.tournament_type == "UNIKÃTNÃ":
        key = f"{st.session_state.players}_{st.session_state.group_size}"
        raw_def = SEATING_DEFINITIONS[key]["rounds"][:st.session_state.rounds]
        schedule = []
        for rnd in raw_def:
            round_groups = []
            for group in rnd:
                group_filtered = [p for p in group if p <= st.session_state.players]
                if len(group_filtered) == len(group):
                    round_groups.append([st.session_state.player_names[p - 1] for p in group_filtered])
            schedule.append(round_groups)
        st.session_state.rozlosovani = schedule
    else:
        first_round = generate_swiss_round(st.session_state.player_names.copy(), st.session_state.group_size, 1)
        st.session_state.rozlosovani = [first_round]
        for _ in range(1, st.session_state.rounds):
            st.session_state.rozlosovani.append([])

# ===== ZOBRAZENÃ ROZLOSOVÃNÃ NEBO POKRAÄŒOVÃNÃ =====
if 'rozlosovani' in st.session_state and 'results' not in st.session_state and not st.session_state.get('finished'):
    st.subheader("ğŸ“‹ RozlosovÃ¡nÃ­")
    
    # Pokud uÅ¾ mÃ¡me nÄ›jakÃ© vÃ½sledky (naÄtenÃ© ze souboru), ukÃ¡Å¾eme pÅ™ehled
    if st.session_state.get('results'):
        st.info("ğŸ”„ NaÄtenÃ½ turnaj - pÅ™ehled vÃ½sledkÅ¯")
        all_rounds = [entry for r in st.session_state.results.values() for entry in r]
        if all_rounds:
            df_preview = pd.DataFrame(all_rounds)
            df_preview = df_preview.groupby("HrÃ¡Ä")["Zisk"].sum().reset_index().sort_values(by="Zisk", ascending=False)
            st.markdown("### ğŸ“ˆ AktuÃ¡lnÃ­ poÅ™adÃ­")
            st.dataframe(df_preview, use_container_width=True, hide_index=True)
        
        # TlaÄÃ­tko pro pokraÄovÃ¡nÃ­ v zadÃ¡vÃ¡nÃ­
        if st.button("â¡ï¸ PokraÄovat v zadÃ¡vÃ¡nÃ­ vÃ½sledkÅ¯"):
            st.session_state.current_round = st.session_state.get('current_round', 1)
            st.rerun()
    else:
        # NormÃ¡lnÃ­ zobrazenÃ­ rozlosovÃ¡nÃ­ pro novÃ½ turnaj
        for rnd_idx, rnd in enumerate(st.session_state.rozlosovani, 1):
            st.markdown(f"### Kolo {rnd_idx}")
            if rnd:
                for table_idx, group in enumerate(rnd, 1):
                    st.write(f"StÅ¯l {table_idx}: {', '.join(group)}")
            else:
                st.write("(RozlosovÃ¡nÃ­ bude vygenerovÃ¡no po zadÃ¡nÃ­ pÅ™edchozÃ­ho kola)")

        if st.button("ZadÃ¡vat vÃ½sledky"):
            st.session_state.results = {}
            st.session_state.current_round = 1
            st.rerun()

# ===== Krok 4: ZadÃ¡vÃ¡nÃ­ vÃ½sledkÅ¯ =====
if 'results' in st.session_state and not st.session_state.get('finished'):
    rnd_idx = st.session_state.current_round
    schedule = st.session_state.rozlosovani
    
    # For Swiss system, generate next round if needed
    if st.session_state.tournament_type == "Å VÃCARSKÃ SYSTÃ‰M" and rnd_idx > 1 and len(schedule) >= rnd_idx and not schedule[rnd_idx-1]:
        next_round = generate_swiss_round(st.session_state.player_names.copy(), st.session_state.group_size, rnd_idx)
        st.session_state.rozlosovani[rnd_idx-1] = next_round
        schedule = st.session_state.rozlosovani
    
    st.subheader(f"âœï¸ ZadÃ¡nÃ­ vÃ½sledkÅ¯ â€“ Kolo {rnd_idx}")
    
    # ZobrazÃ­me pÅ™ehled pÅ™edchozÃ­ch kol pokud existujÃ­
    if st.session_state.results and rnd_idx > 1:
        st.info(f"ğŸ“Š MÃ¡te zadÃ¡no {len(st.session_state.results)} kol")
    
    round_data = []
    valid_round = True
    
    for table_idx, group in enumerate(schedule[rnd_idx - 1], 1):
        st.markdown(f"**StÅ¯l {table_idx}: {', '.join(group)}**")
        sum_na_stole, sum_dokup = 0, 0
        table_entries = []
        
        for player in group:
            col1, col2 = st.columns(2)
            with col1:
                na_stole = st.number_input(f"{player} â€“ na stole (KÄ)", min_value=0, step=10, key=f"stole_{rnd_idx}_{table_idx}_{player}")
            with col2:
                dokup = st.number_input(f"{player} â€“ dokup (KÄ)", min_value=0, step=10, key=f"dokup_{rnd_idx}_{table_idx}_{player}")
            sum_na_stole += na_stole
            sum_dokup += dokup
            zisk = na_stole - st.session_state.vklad - dokup
            table_entries.append({"HrÃ¡Ä": player, "Na stole": na_stole, "Dokup": dokup, "StÅ¯l": table_idx, "Kolo": rnd_idx, "Zisk": zisk})

        expected = st.session_state.vklad * len(group)
        diff = expected + sum_dokup - sum_na_stole
        if diff != 0:
            st.error(f"âŒ NesedÃ­ vklady: rozdÃ­l {diff} KÄ")
            valid_round = False
        else:
            st.success("âœ… Vklady souhlasÃ­")

        df_table = pd.DataFrame(table_entries)
        max_zisk = df_table["Zisk"].max()
        min_zisk = df_table["Zisk"].min()
        for _, row in df_table.iterrows():
            style = ""
            if row["Zisk"] == max_zisk:
                style = "color:green; font-weight:bold"
            elif row["Zisk"] == min_zisk:
                style = "color:red; font-weight:bold"
            st.markdown(f"<div style='{style}'>{row['HrÃ¡Ä']}: zisk {row['Zisk']} KÄ</div>", unsafe_allow_html=True)

        round_data.extend(table_entries)

    # PrÅ¯bÄ›Å¾nÃ© poÅ™adÃ­ - POUZE Z ULOÅ½ENÃCH KOL
    all_rounds_preview = [entry for r in st.session_state.results.values() for entry in r]
    if all_rounds_preview:
        df_preview = pd.DataFrame(all_rounds_preview)
        df_preview = df_preview.groupby("HrÃ¡Ä")["Zisk"].sum().reset_index().sort_values(by="Zisk", ascending=False)
        
        st.markdown("### ğŸ“ˆ PrÅ¯bÄ›Å¾nÃ© poÅ™adÃ­")
        st.dataframe(df_preview, use_container_width=True, hide_index=True)

    # TlaÄÃ­tka pro akce
    col1, col2, col3 = st.columns(3)
    
    with col1:
        tournament_json = export_tournament_data()
        st.download_button(
            label="ğŸ’¾ UloÅ¾it a pozastavit",
            data=tournament_json,
            file_name=f"marias_turnaj_kolo_{rnd_idx}_{pd.Timestamp.now().strftime('%Y%m%d_%H%M')}.json",
            mime="application/json",
            key=f"save_pause_{rnd_idx}"
        )
    
    with col2:
        if st.button("ğŸ“… UloÅ¾it kolo a pokraÄovat", key=f"save_continue_{rnd_idx}"):
            if not valid_round:
                st.warning("Nelze uloÅ¾it kolo, dokud nejsou vklady vyrovnanÃ©.")
            else:
                # ULOÅ½ENÃ VÃSLEDKÅ® KOLA
                st.session_state.results[rnd_idx] = round_data
                st.success(f"Kolo {rnd_idx} ÃºspÄ›Å¡nÄ› uloÅ¾eno!")
                
                # Aktualizace skÃ³re pro Å vÃ½carskÃ½ systÃ©m
                if st.session_state.tournament_type == "Å VÃCARSKÃ SYSTÃ‰M":
                    for entry in round_data:
                        player = entry["HrÃ¡Ä"]
                        zisk = entry["Zisk"]
                        st.session_state.player_scores[player] = st.session_state.player_scores.get(player, 0) + zisk
                
                # PÅ™esun na dalÅ¡Ã­ kolo nebo konec
                if rnd_idx < st.session_state.rounds:
                    st.session_state.current_round += 1
                    st.rerun()
                else:
                    st.success("ğŸ‰ VÅ¡echna kola byla zadÃ¡na!")
                    st.session_state.finished = True
                    st.rerun()
    
    with col3:
        if rnd_idx > 1 and st.button("â®ï¸ Zobrazit pÅ™edchozÃ­ kola", key=f"go_back_{rnd_idx}"):
            st.session_state.show_previous = True
            st.rerun()

# ===== ZOBRAZENÃ PÅ˜EDCHOZÃCH KOL =====
if st.session_state.get('show_previous'):
    st.subheader("ğŸ“œ PÅ™ehled zadanÃ½ch kol")
    
    all_results = []
    for rnd_idx in sorted(int(k) for k in st.session_state.results.keys()):
        entries = st.session_state.results.get(str(rnd_idx), [])
        if entries:
            st.markdown(f"### Kolo {rnd_idx}")
            df = pd.DataFrame(entries)
            df["Zisk"] = df["Zisk"].astype(int)

            max_zisk = df["Zisk"].max()
            min_zisk = df["Zisk"].min()

            def color_zisk(val):
                if val == max_zisk:
                    return "background-color: #d4f7d4; font-weight: bold"
                elif val == min_zisk:
                    return "background-color: #fdd; font-weight: bold"
                return ""

            styled_df = df.style.map(color_zisk, subset=["Zisk"])
            st.dataframe(styled_df, use_container_width=True, hide_index=True)
            
            for e in entries:
                all_results.append(e)
    
    if all_results:
        df_all = pd.DataFrame(all_results)
        total_zisky = df_all.groupby("HrÃ¡Ä")["Zisk"].sum().sort_values(ascending=False)
        st.markdown("### ğŸ“Š CelkovÃ© poÅ™adÃ­")
        for hrac, zisk in total_zisky.items():
            color = "green" if zisk > 0 else ("red" if zisk < 0 else "black")
            st.markdown(f"<span style='color:{color}; font-weight:bold'>{hrac}: {zisk:+} KÄ</span>", unsafe_allow_html=True)
    
    if st.button("â†©ï¸ VrÃ¡tit se k zadÃ¡vÃ¡nÃ­"):
        st.session_state.show_previous = False
        st.rerun()

# ===== Po poslednÃ­m kole: souhrn kol a export =====
if st.session_state.get("finished") and "results" in st.session_state:
    st.subheader("ğŸ“œ VÃ½sledky vÅ¡ech kol")
    
    st.download_button(
        label="ğŸ’¾ UloÅ¾it kompletnÃ­ turnaj",
        data=export_tournament_data(),
        file_name=f"marias_turnaj_kompletni_{pd.Timestamp.now().strftime('%Y%m%d_%H%M')}.json",
        mime="application/json"
    )

    all_results = []
    
    # Projdeme vÅ¡echna kola od 1 do celkovÃ©ho poÄtu kol
    for rnd_idx in range(1, st.session_state.rounds + 1):
        # ZÃ­skÃ¡nÃ­ vÃ½sledkÅ¯ pro danÃ© kolo
        entries = st.session_state.results.get(str(rnd_idx), [])
        
        st.markdown(f"### ğŸ•’ Kolo {rnd_idx}")
        
        if entries:
            df = pd.DataFrame(entries)
            df["Zisk"] = df["Zisk"].astype(int)

            max_zisk = df["Zisk"].max()
            min_zisk = df["Zisk"].min()

            def color_zisk(val):
                if val == max_zisk:
                    return "background-color: #d4f7d4; font-weight: bold"
                elif val == min_zisk:
                    return "background-color: #fdd; font-weight: bold"
                return ""

            styled_df = df.style.map(color_zisk, subset=["Zisk"])
            st.dataframe(styled_df, use_container_width=True, hide_index=True)

            for e in entries:
                e["Kolo"] = rnd_idx
                all_results.append(e)
        else:
            st.info(f"Kolo {rnd_idx} nemÃ¡ zadanÃ© vÃ½sledky")

    df_all = pd.DataFrame(all_results)

    # CelkovÃ© zisky
    st.subheader("ğŸ’° KoneÄnÃ½ zisk hrÃ¡ÄÅ¯")
    total_zisky = df_all.groupby("HrÃ¡Ä")["Zisk"].sum().sort_values(ascending=False)
    for hrac, zisk in total_zisky.items():
        color = "green" if zisk > 0 else ("red" if zisk < 0 else "black")
        st.markdown(f"<span style='color:{color}; font-weight:bold'>{hrac}: {zisk:+} KÄ</span>", unsafe_allow_html=True)

    # Export do CSV
    csv_buffer = io.BytesIO()
    csv_content = df_all.to_csv(index=False, sep=";", encoding="cp1250")
    csv_buffer.write(csv_content.encode("cp1250"))
    csv_buffer.seek(0)
    
    st.download_button(
        label="ğŸ“… StÃ¡hnout vÃ½sledky jako CSV",
        data=csv_buffer,
        file_name="vysledky_marias.csv",
        mime="text/csv"
    )

    # Export HTML pro tisk/PDF
    html_output = "<h2>VÃ½sledky mariÃ¡Å¡ovÃ©ho turnaje</h2>"
    for rnd_idx in range(1, st.session_state.rounds + 1):
        entries = st.session_state.results.get(str(rnd_idx), [])
        if not entries:
            continue
        html_output += f"<h3>Kolo {rnd_idx}</h3><table border='1' cellspacing='0' cellpadding='4'><tr><th>HrÃ¡Ä</th><th>Na stole</th><th>Dokup</th><th>Zisk</th></tr>"
        df = pd.DataFrame(entries)
        max_zisk = df["Zisk"].max()
        min_zisk = df["Zisk"].min()
        for _, row in df.iterrows():
            style = ""
            if row["Zisk"] == max_zisk:
                style = " style='background-color:#d4f7d4; font-weight:bold'"
            elif row["Zisk"] == min_zisk:
                style = " style='background-color:#fdd; font-weight:bold'"
            html_output += f"<tr{style}><td>{row['HrÃ¡Ä']}</td><td>{row['Na stole']}</td><td>{row['Dokup']}</td><td>{row['Zisk']}</td></tr>"
        html_output += "</table><br>"

    html_output += "<h3>KoneÄnÃ½ zisk hrÃ¡ÄÅ¯</h3><ul>"
    for hrac, zisk in total_zisky.items():
        color = "green" if zisk > 0 else ("red" if zisk < 0 else "black")
        html_output += f"<li><span style='color:{color}; font-weight:bold'>{hrac}: {zisk:+} KÄ</span></li>"
    html_output += "</ul>"

    with tempfile.NamedTemporaryFile("w", delete=False, suffix=".html", encoding="utf-8") as f:
        f.write(html_output)
        html_path = f.name

    with open(html_path, "r", encoding="utf-8") as f:
        html_data = f.read()

    st.download_button(
        label="ğŸ–Šï¸ StÃ¡hnout vÃ½sledky jako HTML (pro tisk nebo PDF)",
        data=html_data,
        file_name="vysledky_turnaje.html",
        mime="text/html"
    )

